import {createAsyncThunk} from "@reduxjs/toolkit";
import {api_post_headers} from "../services/api_post_headers";
import {api_headers} from "../services/api_headers";
import {au_api_headers} from "../services/au_api_headers";

//Start a conversation. Creation of a new thread.
export const addThread = createAsyncThunk(
    'addThread',
    async ({ name, email, auth_field, phone, phone_country, body, post_id, captcha_key, filename }, { rejectWithValue }) => {
        try {
            let auth_field = auth_field ? auth_field : "email";

            fetch(`${process.env.REACT_APP_API_URL}threads`, {
                method: 'POST',
                mode: "cors",
                headers: api_post_headers,
                body: JSON.stringify({
                    "name": {name},    //The thread's creator name.    ( optional  )
                    "auth_field": {auth_field},      //The user's auth field ('email' or 'phone').    ( optional  )
                    "email": {email},           //The thread's creator email address (Required when 'auth_field' value is 'email').    ( optional  )
                    "phone": {phone},           //The thread's creator mobile phone number (Required when 'auth_field' value is 'phone').   ( optional  )
                    "phone_country": {phone_country},           //The user's phone number's country code (Required when the 'phone' field is filled).   ( optional  )
                    "body": {body},             //The name of the user.       ( optional  )
                    "post_id": {post_id},       //The related post ID.       ( optional  )
                    'captcha_key': 'vero',      //The thread attached file.  ( optional  )
                    'filename': document.querySelector('input[name="filename"]').files[0]           //Key generated by the CAPTCHA endpoint calling (Required when the CAPTCHA verification is enabled from the Admin panel).  ( optional  )

                })
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)

export const getThread = createAsyncThunk(
    'getThread',
    async ({ threadId }, { rejectWithValue }) => {
        try {  //
            const url = new URL(
                `${process.env.REACT_APP_API_URL}threads/${threadId}`   //The thread's ID.
            );
            const params = {
                "embed": "null",        // Comma-separated list of the post relationships for Eager Loading - Possible values: user,post,messages,participants.
            };
            Object.keys(params)
                .forEach(key => url.searchParams.append(key, params[key]));

            fetch(url, {
                method: 'GET',
                mode: "cors",
                headers: au_api_headers,
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)


export const updateThread = createAsyncThunk(
    'updateThread',
    async ({ threadId, content, filename }, { rejectWithValue }) => {
        try {

            fetch(`${process.env.REACT_APP_API_URL}posts/${threadId}`, {
                method: 'PUT',
                mode: "cors",
                headers: api_post_headers,
                body: JSON.stringify({
                    "content": {content},
                    'filename': document.querySelector('input[name="filename"]').files[0]

                })
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)

export const deleteThread = createAsyncThunk(
    'deleteThread',
    async ({ threadIds }, { rejectWithValue }) => {
        try {  // where threadIds is the ID or comma-separated IDs list of thread(s)

            fetch(`${process.env.REACT_APP_API_URL}threads/${threadIds}`, {
                method: 'DELETE',
                mode: "cors",
                headers: api_headers
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)

export const bulkUpdateThread = createAsyncThunk(
    'bulkUpdateThread',
    async ({ Ids, type }, { rejectWithValue }) => {
        try {
            let auth_field = auth_field ? auth_field : "email";
            const url = new URL(
                `${process.env.REACT_APP_API_URL}threads/bulkUpdate/${Ids}`     //The ID or comma-separated IDs list of thread(s).
            );

            const params = {
                "type": { type },   //The type of action to execute (markAsRead, markAsUnread, markAsImportant, markAsNotImportant or markAllAsRead).
            };
            Object.keys(params)
                .forEach(key => url.searchParams.append(key, params[key]));

            fetch(url, {
                method: 'POST',
                mode: "cors",
                headers: au_api_headers,
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)

export const listThreadMessages = createAsyncThunk(
    'listThreadMessages',
    async ({ threadId, embed, sort, pageLimit }, { rejectWithValue }) => {
        try {  //
            const url = new URL(
                `${process.env.REACT_APP_API_URL}threads/${ threadId }/messages`
            );
            let embed = embed ? embed : "null";
            let sort = sort ? sort : "created_at";
            let pageLimit = pageLimit ? pageLimit : 20;

            const params = {
                "embed": { embed },    //The Comma-separated list of the category relationships for Eager Loading - Possible values: user,country.
                "sort": { sort },  //The sorting parameter (Order by DESC with the given column. Use "-" as prefix to order by ASC). Possible values: created_at.
                "perPage": { pageLimit },  //Items per page. Can be defined globally from the admin settings. Cannot be exceeded 100.
            };
            Object.keys(params)
                .forEach(key => url.searchParams.append(key, params[key]));

            fetch(url, {
                method: 'GET',
                mode: "cors",
                headers: au_api_headers,
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)

export const getThreadMessage = createAsyncThunk(
    'getThreadMessage',
    async ({ threadId, Id }, { rejectWithValue }) => {
        try {  //
            const url = new URL(
                `${process.env.REACT_APP_API_URL}threads/${threadId}/messages/${Id}`
            );
            let embed = embed ? embed : "null";
            const params = {
                "embed": {embed},           //The Comma-separated list of the category relationships for Eager Loading - Possible values: user,country,pictures,postType,category,city,country. (optional)
            };
            Object.keys(params)
                .forEach(key => url.searchParams.append(key, params[key]));

            fetch(url, {
                method: 'GET',
                mode: "cors",
                headers: au_api_headers,
            }).then(response => {
                return response.json()
            })
        } catch (error) {
            if (error.response && error.response.data.message) {
                return rejectWithValue(error.response.data.message)
            } else {
                return rejectWithValue(error.message)
            }
        }
    }
)